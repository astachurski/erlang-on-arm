/*
 * beam_emu.c
 *
 *  Created on: Oct 26, 2013
 *      Author: Studnicki
 */

#include "global.h"
#include "beam_emu.h"
#include "beam_load.h"

static int init_done = 0;

void go(BeamInstr* start) {
	//first time this function is called op labels from here are exported to the loader
	if(!init_done) {
		int i;
		void* temp[] = { JUMP_TABLE };
		for(i=0; i<154; i++) {
				jump_table[i] = (BeamInstr)temp[i];

				char buf[256];
					sprintf(buf, "%d\n", jump_table[i]);
					debug(buf);

		}
		init_done = 1;
		return;
	}

	register Eterm x0;
	register Eterm* reg = NULL;
	register BeamInstr *I = NULL;

	I = start;

	Goto(*I);

	OpCase(LABEL):
		debug("label\n");
		I+=2;
		Goto(*I);
	OpCase(FUNC_INFO):
		debug("func_info\n");
		I+=4;
		Goto(*I);
	OpCase(INT_CODE_END):
		debug("int_code_end\n");
		I+=1;
		return;
	OpCase(CALL):
		debug("call\n");
		I+=3;
		Goto(*I);
	OpCase(CALL_LAST):
		debug("call_last\n");
		I+=4;
		Goto(*I);
	OpCase(CALL_ONLY):
		debug("call_only\n");
		I+=3;
		Goto(*I);
	OpCase(CALL_EXT):
		debug("call_ext\n");
		I+=3;
		Goto(*I);
	OpCase(CALL_EXT_LAST):
		debug("call_ext_last\n");
		I+=4;
		Goto(*I);
	OpCase(BIF0):
		debug("bif0\n");
		I+=3;
		Goto(*I);
	OpCase(BIF1):
		debug("bif1\n");
		I+=5;
		Goto(*I);
	OpCase(BIF2):
		debug("bif2\n");
		I+=6;
		Goto(*I);
	OpCase(ALLOCATE):
		debug("allocate\n");
		I+=3;
		Goto(*I);
	OpCase(ALLOCATE_HEAP):
		debug("allocate_heap\n");
		I+=4;
		Goto(*I);
	OpCase(ALLOCATE_ZERO):
		debug("allocate_zero\n");
		I+=3;
		Goto(*I);
	OpCase(ALLOCATE_HEAP_ZERO):
		debug("allocate_heap_zero\n");
		I+=4;
		Goto(*I);
	OpCase(TEST_HEAP):
		debug("test_heap\n");
		I+=3;
		Goto(*I);
	OpCase(INIT):
		debug("init\n");
		I+=2;
		Goto(*I);
	OpCase(DEALLOCATE):
		debug("deallocate\n");
		I+=2;
		Goto(*I);
	OpCase(RETURN):
		debug("return\n");
		I+=1;
		Goto(*I);
	OpCase(SEND):
		debug("send\n");
		I+=1;
		Goto(*I);
	OpCase(REMOVE_MESSAGE):
		debug("remove_message\n");
		I+=1;
		Goto(*I);
	OpCase(TIMEOUT):
		debug("timeout\n");
		I+=1;
		Goto(*I);
	OpCase(LOOP_REC):
		debug("loop_rec\n");
		I+=3;
		Goto(*I);
	OpCase(LOOP_REC_END):
		debug("loop_rec_end\n");
		I+=2;
		Goto(*I);
	OpCase(WAIT):
		debug("wait\n");
		I+=2;
		Goto(*I);
	OpCase(WAIT_TIMEOUT):
		debug("wait_timeout\n");
		I+=3;
		Goto(*I);
	OpCase(M_PLUS):
		debug("m_plus\n");
		I+=5;
		Goto(*I);
	OpCase(M_MINUS):
		debug("m_minus\n");
		I+=5;
		Goto(*I);
	OpCase(M_TIMES):
		debug("m_times\n");
		I+=5;
		Goto(*I);
	OpCase(M_DIV):
		debug("m_div\n");
		I+=5;
		Goto(*I);
	OpCase(INT_DIV):
		debug("int_div\n");
		I+=5;
		Goto(*I);
	OpCase(INT_REM):
		debug("int_rem\n");
		I+=5;
		Goto(*I);
	OpCase(INT_BAND):
		debug("int_band\n");
		I+=5;
		Goto(*I);
	OpCase(INT_BOR):
		debug("int_bor\n");
		I+=5;
		Goto(*I);
	OpCase(INT_BXOR):
		debug("int_bxor\n");
		I+=5;
		Goto(*I);
	OpCase(INT_BSL):
		debug("int_bsl\n");
		I+=5;
		Goto(*I);
	OpCase(INT_BSR):
		debug("int_bsr\n");
		I+=5;
		Goto(*I);
	OpCase(INT_BNOT):
		debug("int_bnot\n");
		I+=4;
		Goto(*I);
	OpCase(IS_LT):
		debug("is_lt\n");
		I+=4;
		Goto(*I);
	OpCase(IS_GE):
		debug("is_ge\n");
		I+=4;
		Goto(*I);
	OpCase(IS_EQ):
		debug("is_eq\n");
		I+=4;
		Goto(*I);
	OpCase(IS_NE):
		debug("is_ne\n");
		I+=4;
		Goto(*I);
	OpCase(IS_EQ_EXACT):
		debug("is_eq_exact\n");
		I+=4;
		Goto(*I);
	OpCase(IS_NE_EXACT):
		debug("is_ne_exact\n");
		I+=4;
		Goto(*I);
	OpCase(IS_INTEGER):
		debug("is_integer\n");
		I+=3;
		Goto(*I);
	OpCase(IS_FLOAT):
		debug("is_float\n");
		I+=3;
		Goto(*I);
	OpCase(IS_NUMBER):
		debug("is_number\n");
		I+=3;
		Goto(*I);
	OpCase(IS_ATOM):
		debug("is_atom\n");
		I+=3;
		Goto(*I);
	OpCase(IS_PID):
		debug("is_pid\n");
		I+=3;
		Goto(*I);
	OpCase(IS_REFERENCE):
		debug("is_reference\n");
		I+=3;
		Goto(*I);
	OpCase(IS_PORT):
		debug("is_port\n");
		I+=3;
		Goto(*I);
	OpCase(IS_NIL):
		debug("is_nil\n");
		I+=3;
		Goto(*I);
	OpCase(IS_BINARY):
		debug("is_binary\n");
		I+=3;
		Goto(*I);
	OpCase(IS_CONSTANT):
		debug("is_constant\n");
		I+=3;
		Goto(*I);
	OpCase(IS_LIST):
		debug("is_list\n");
		I+=3;
		Goto(*I);
	OpCase(IS_NONEMPTY_LIST):
		debug("is_nonempty_list\n");
		I+=3;
		Goto(*I);
	OpCase(IS_TUPLE):
		debug("is_tuple\n");
		I+=3;
		Goto(*I);
	OpCase(TEST_ARITY):
		debug("test_arity\n");
		I+=4;
		Goto(*I);
	OpCase(SELECT_VAL):
		debug("select_val\n");
		I+=4;
		Goto(*I);
	OpCase(SELECT_TUPLE_ARITY):
		debug("select_tuple_arity\n");
		I+=4;
		Goto(*I);
	OpCase(JUMP):
		debug("jump\n");
		I+=2;
		Goto(*I);
	OpCase(CATCH):
		debug("catch\n");
		I+=3;
		Goto(*I);
	OpCase(CATCH_END):
		debug("catch_end\n");
		I+=2;
		Goto(*I);
	OpCase(MOVE):
		debug("move\n");
		I+=3;
		Goto(*I);
	OpCase(GET_LIST):
		debug("get_list\n");
		I+=4;
		Goto(*I);
	OpCase(GET_TUPLE_ELEMENT):
		debug("get_tuple_element\n");
		I+=4;
		Goto(*I);
	OpCase(SET_TUPLE_ELEMENT):
		debug("set_tuple_element\n");
		I+=4;
		Goto(*I);
	OpCase(PUT_STRING):
		debug("put_string\n");
		I+=4;
		Goto(*I);
	OpCase(PUT_LIST):
		debug("put_list\n");
		I+=4;
		Goto(*I);
	OpCase(PUT_TUPLE):
		debug("put_tuple\n");
		I+=3;
		Goto(*I);
	OpCase(PUT):
		debug("put\n");
		I+=2;
		Goto(*I);
	OpCase(BADMATCH):
		debug("badmatch\n");
		I+=2;
		Goto(*I);
	OpCase(IF_END):
		debug("if_end\n");
		I+=1;
		Goto(*I);
	OpCase(CASE_END):
		debug("case_end\n");
		I+=2;
		Goto(*I);
	OpCase(CALL_FUN):
		debug("call_fun\n");
		I+=2;
		Goto(*I);
	OpCase(MAKE_FUN):
		debug("make_fun\n");
		I+=4;
		Goto(*I);
	OpCase(IS_FUNCTION):
		debug("is_function\n");
		I+=3;
		Goto(*I);
	OpCase(CALL_EXT_ONLY):
		debug("call_ext_only\n");
		I+=3;
		Goto(*I);
	OpCase(BS_START_MATCH):
		debug("bs_start_match\n");
		I+=3;
		Goto(*I);
	OpCase(BS_GET_INTEGER):
		debug("bs_get_integer\n");
		I+=6;
		Goto(*I);
	OpCase(BS_GET_FLOAT):
		debug("bs_get_float\n");
		I+=6;
		Goto(*I);
	OpCase(BS_GET_BINARY):
		debug("bs_get_binary\n");
		I+=6;
		Goto(*I);
	OpCase(BS_SKIP_BITS):
		debug("bs_skip_bits\n");
		I+=5;
		Goto(*I);
	OpCase(BS_TEST_TAIL):
		debug("bs_test_tail\n");
		I+=3;
		Goto(*I);
	OpCase(BS_SAVE):
		debug("bs_save\n");
		I+=2;
		Goto(*I);
	OpCase(BS_RESTORE):
		debug("bs_restore\n");
		I+=2;
		Goto(*I);
	OpCase(BS_INIT):
		debug("bs_init\n");
		I+=3;
		Goto(*I);
	OpCase(BS_FINAL):
		debug("bs_final\n");
		I+=3;
		Goto(*I);
	OpCase(BS_PUT_INTEGER):
		debug("bs_put_integer\n");
		I+=6;
		Goto(*I);
	OpCase(BS_PUT_BINARY):
		debug("bs_put_binary\n");
		I+=6;
		Goto(*I);
	OpCase(BS_PUT_FLOAT):
		debug("bs_put_float\n");
		I+=6;
		Goto(*I);
	OpCase(BS_PUT_STRING):
		debug("bs_put_string\n");
		I+=3;
		Goto(*I);
	OpCase(BS_NEED_BUF):
		debug("bs_need_buf\n");
		I+=2;
		Goto(*I);
	OpCase(FCLEARERROR):
		debug("fclearerror\n");
		I+=1;
		Goto(*I);
	OpCase(FCHECKERROR):
		debug("fcheckerror\n");
		I+=2;
		Goto(*I);
	OpCase(FMOVE):
		debug("fmove\n");
		I+=3;
		Goto(*I);
	OpCase(FCONV):
		debug("fconv\n");
		I+=3;
		Goto(*I);
	OpCase(FADD):
		debug("fadd\n");
		I+=5;
		Goto(*I);
	OpCase(FSUB):
		debug("fsub\n");
		I+=5;
		Goto(*I);
	OpCase(FMUL):
		debug("fmul\n");
		I+=5;
		Goto(*I);
	OpCase(FDIV):
		debug("fdiv\n");
		I+=5;
		Goto(*I);
	OpCase(FNEGATE):
		debug("fnegate\n");
		I+=4;
		Goto(*I);
	OpCase(MAKE_FUN2):
		debug("make_fun2\n");
		I+=2;
		Goto(*I);
	OpCase(TRY):
		debug("try\n");
		I+=3;
		Goto(*I);
	OpCase(TRY_END):
		debug("try_end\n");
		I+=2;
		Goto(*I);
	OpCase(TRY_CASE):
		debug("try_case\n");
		I+=2;
		Goto(*I);
	OpCase(TRY_CASE_END):
		debug("try_case_end\n");
		I+=2;
		Goto(*I);
	OpCase(RAISE):
		debug("raise\n");
		I+=3;
		Goto(*I);
	OpCase(BS_INIT2):
		debug("bs_init2\n");
		I+=7;
		Goto(*I);
	OpCase(BS_BITS_TO_BYTES):
		debug("bs_bits_to_bytes\n");
		I+=4;
		Goto(*I);
	OpCase(BS_ADD):
		debug("bs_add\n");
		I+=6;
		Goto(*I);
	OpCase(APPLY):
		debug("apply\n");
		I+=2;
		Goto(*I);
	OpCase(APPLY_LAST):
		debug("apply_last\n");
		I+=3;
		Goto(*I);
	OpCase(IS_BOOLEAN):
		debug("is_boolean\n");
		I+=3;
		Goto(*I);
	OpCase(IS_FUNCTION2):
		debug("is_function2\n");
		I+=4;
		Goto(*I);
	OpCase(BS_START_MATCH2):
		debug("bs_start_match2\n");
		I+=6;
		Goto(*I);
	OpCase(BS_GET_INTEGER2):
		debug("bs_get_integer2\n");
		I+=8;
		Goto(*I);
	OpCase(BS_GET_FLOAT2):
		debug("bs_get_float2\n");
		I+=8;
		Goto(*I);
	OpCase(BS_GET_BINARY2):
		debug("bs_get_binary2\n");
		I+=8;
		Goto(*I);
	OpCase(BS_SKIP_BITS2):
		debug("bs_skip_bits2\n");
		I+=6;
		Goto(*I);
	OpCase(BS_TEST_TAIL2):
		debug("bs_test_tail2\n");
		I+=4;
		Goto(*I);
	OpCase(BS_SAVE2):
		debug("bs_save2\n");
		I+=3;
		Goto(*I);
	OpCase(BS_RESTORE2):
		debug("bs_restore2\n");
		I+=3;
		Goto(*I);
	OpCase(GC_BIF1):
		debug("gc_bif1\n");
		I+=6;
		Goto(*I);
	OpCase(GC_BIF2):
		debug("gc_bif2\n");
		I+=7;
		Goto(*I);
	OpCase(BS_FINAL2):
		debug("bs_final2\n");
		I+=3;
		Goto(*I);
	OpCase(BS_BITS_TO_BYTES2):
		debug("bs_bits_to_bytes2\n");
		I+=3;
		Goto(*I);
	OpCase(PUT_LITERAL):
		debug("put_literal\n");
		I+=3;
		Goto(*I);
	OpCase(IS_BITSTR):
		debug("is_bitstr\n");
		I+=3;
		Goto(*I);
	OpCase(BS_CONTEXT_TO_BINARY):
		debug("bs_context_to_binary\n");
		I+=2;
		Goto(*I);
	OpCase(BS_TEST_UNIT):
		debug("bs_test_unit\n");
		I+=4;
		Goto(*I);
	OpCase(BS_MATCH_STRING):
		debug("bs_match_string\n");
		I+=5;
		Goto(*I);
	OpCase(BS_INIT_WRITABLE):
		debug("bs_init_writable\n");
		I+=1;
		Goto(*I);
	OpCase(BS_APPEND):
		debug("bs_append\n");
		I+=9;
		Goto(*I);
	OpCase(BS_PRIVATE_APPEND):
		debug("bs_private_append\n");
		I+=7;
		Goto(*I);
	OpCase(TRIM):
		debug("trim\n");
		I+=3;
		Goto(*I);
	OpCase(BS_INIT_BITS):
		debug("bs_init_bits\n");
		I+=7;
		Goto(*I);
	OpCase(BS_GET_UTF8):
		debug("bs_get_utf8\n");
		I+=6;
		Goto(*I);
	OpCase(BS_SKIP_UTF8):
		debug("bs_skip_utf8\n");
		I+=5;
		Goto(*I);
	OpCase(BS_GET_UTF16):
		debug("bs_get_utf16\n");
		I+=6;
		Goto(*I);
	OpCase(BS_SKIP_UTF16):
		debug("bs_skip_utf16\n");
		I+=5;
		Goto(*I);
	OpCase(BS_GET_UTF32):
		debug("bs_get_utf32\n");
		I+=6;
		Goto(*I);
	OpCase(BS_SKIP_UTF32):
		debug("bs_skip_utf32\n");
		I+=5;
		Goto(*I);
	OpCase(BS_UTF8_SIZE):
		debug("bs_utf8_size\n");
		I+=4;
		Goto(*I);
	OpCase(BS_PUT_UTF8):
		debug("bs_put_utf8\n");
		I+=4;
		Goto(*I);
	OpCase(BS_UTF16_SIZE):
		debug("bs_utf16_size\n");
		I+=4;
		Goto(*I);
	OpCase(BS_PUT_UTF16):
		debug("bs_put_utf16\n");
		I+=4;
		Goto(*I);
	OpCase(BS_PUT_UTF32):
		debug("bs_put_utf32\n");
		I+=4;
		Goto(*I);
	OpCase(ON_LOAD):
		debug("on_load\n");
		I+=1;
		Goto(*I);
	OpCase(RECV_MARK):
		debug("recv_mark\n");
		I+=2;
		Goto(*I);
	OpCase(RECV_SET):
		debug("recv_set\n");
		I+=2;
		Goto(*I);
	OpCase(GC_BIF3):
		debug("gc_bif3\n");
		I+=8;
		Goto(*I);
	OpCase(LINE):
		debug("line\n");
		I+=2;
		Goto(*I);
}
